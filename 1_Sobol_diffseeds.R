# Standard Sobol analysis
# Note: if you want to run the code for a replication check, all the output results should be the same as
#       the example outputs except for the computational time (because the machines are different). 
#       This note applies to all the scripts in this study.


# Remove all existing environment and plots
rm(list = ls())
graphics.off()

source("0_library.R")

#necessary packages for parallelization
library("foreach")
library("doParallel")

print("1_Sobol_diffseeds.R") 

#setup parallel backend to use many processors
cores=detectCores()
cl <- makeCluster(cores[1]-1) # -1 not to overload system
registerDoParallel(cl)

#foreach executes the code within the brackets separately on each node
foreach(node = 1:4)%dopar%{ 
  
  source("0_library.R")
  
  # Define the test model in each dimension and perform the Sobol analysis
  for (k in 1:3){
    
    seed<- node*k*10
    set.seed(seed)
    
    T_Sobol<- vector()
    T_check_Sobol<- vector()
    all_eval_times<- vector()
    
    # d dimensional model
    d <- D[k]
    
    # Folder for d dimension test scenario under the working directory
    # "Data" is the folder that saves all the relevant parameters during the tests
    folder<-paste0(folderpath,d,"D/Sobol/seed",seed) #set folder depending on both d and node
    if (!dir.exists(folder)) dir.create(folder, recursive = TRUE)
    
    # For each considered sample size, perform the Sobol analysis
    for (m in 1:length(tot_size)){
      
      # "sensobol" package has a special design for a sobol matrix used for the analysis,
      #     N here is the length of the matrix.
      # The relationship between N and the sample size (when calculating up to 2nd order indices) is:
      #     sample size = N*(d+2+d*(d-1)/2)
      # Note we take the nearest integer, hence the actual sample size is an approximation of the list of sample
      #     size we consider. 
      N <- floor(tot_size[m]/(d+2+d*(d-1)/2))
      
      # if N < 2, increase size directly
      if (N >= 2){
        
        # Sensitivity analysis time
        sens_start.time<-Sys.time()
        
        # Input matrix and output. The input matrix is generated by the Sobol sequence algorithm.
        mat <- sobol_matrices(N = N, params = as.character(c(1:d)), order = "second")
        
        Sobol_convergesize<- nrow(mat)
        print(paste0("checking convergence of input ranking at a sample size of ", nrow(mat)))
        
        X <- split(t(mat), rep(1:dim(mat)[1], each = d))
        
        # Model total evaluation time
        start.time<-Sys.time()
        Y <- sapply(X, Testmodel)
        end.time<-Sys.time()
        eval_time <- difftime(end.time,start.time,units = "secs")/length(Y)
        all_eval_times<- c(all_eval_times,eval_time)
        
        #print(paste0("eval_time: ",eval_time))
        
        S <- sobol_indices_boot(Y=Y,N=N,params = as.character(c(1:d)),
                                boot=TRUE,R=100,order="second")
        sens_end.time<-Sys.time()
        time_sobol<-difftime(sens_end.time,sens_start.time,units = "secs")
        T_Sobol<-c(T_Sobol,time_sobol)
        
        #print(paste0("time_sobol: ",time_sobol))
        
        # convergence of ranking:
        start.time <- Sys.time()
        
        Sens <- S$boot$t[ ,c((1+d):(2*d))]
        Rank <- t(apply(Sens, 1, rank))
        for (boot_ind1 in 1:99){
          T <- boot_ind1
          for (boot_ind2 in (T+1):100){
            Rho <- rep(NA,d)
            Weights <- rep(NA,d)
            for (para_ind in 1:d){
              Weights[para_ind] <- (max(Sens[boot_ind1,para_ind],max(Sens[boot_ind2,para_ind])))^2
            }
            Weights_sum <- sum(Weights)
            for (para_ind in 1:d){
              Rho[para_ind] <- abs(Rank[boot_ind1,para_ind]-Rank[boot_ind2,para_ind])*
                Weights[para_ind]/Weights_sum
            }
            if (boot_ind2 == 2){
              Rho_all <- Rho
            } else{
              Rho_all <- append(Rho_all,Rho)
            }
          }
        }
        Rho_all <- matrix(Rho_all, nrow = d)
        Rho_all <- apply(Rho_all, 2, sum)
        
        end.time <- Sys.time()
        time_check <- difftime(end.time,start.time,units = "secs")
        T_check_Sobol<- c(T_check_Sobol,time_check)
        
        #print(paste0("time_check: ",time_check))
        
        #print(paste0("length(T_check_Sobol): ",length(T_check_Sobol)))
        #print(paste0("m: ",m))
        
        save(T_Sobol,file = paste0(folder,"/T_Sobol"))
        save(T_check_Sobol,file=paste0(folder,"/T_check_Sobol"))
        save(S,file=paste0(folder,"/S_Sobol"))
        save(Sobol_convergesize,file=paste0(folder,"/Sobol_convergesize"))
        save(all_eval_times,file = paste0(folder,"/all_eval_times"))
        
        if (!any(is.na(Rho_all))){
          #print(quantile(Rho_all,probs = 0.95, na.rm = TRUE))
          if (quantile(Rho_all,probs = 0.95, na.rm = TRUE) < 1){
            avg_eval_time<- mean(all_eval_times)
            save(avg_eval_time,file = paste0(folder,"/avg_eval_time"))
            print(paste0("Sobol convergence size: ",Sobol_convergesize))
            #print(paste0("tot_size[length(T_check_Sobol)]:", tot_size[length(T_check_Sobol)]))
            break
          }
        }
        
      }
    }
  }
}

